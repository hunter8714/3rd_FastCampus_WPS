Week1_Day3. 자료구조 / 알고리즘 / Database / DBMS / SQL / 연결리스트 /
==

## 0. 목차
>1. 알고리즘<br><br>
>2. 자료구조 <br><br>
>3. 분류 <br><br>
>4. Database<br><br>
>5. DBMS<br><br>
>6. SQL

## 1. 이론

#####1.1. 알고리즘 <br>

>** 알고리즘이란? **

>알고리즘하면 뭔가 굉장히 복잡하고 어려워보이지만, 쉽게 간단히 한마디로 표현해보자면 일을 처리하는 순서/ 방법 등을 말한다.

>길을 찾아가거나 , 여행가방을 싸거나, 누구와 다퉜을 때 화해하려고 하거나 등등

>이런 일련의 모든 행동들(방법들)이 알고리즘이라고 할 수 있는 것이다.

>즉 알고리즘이란, 

>**_무엇을 하려고 할 떄 제일 최적화, 효율적으로 해결해야 할 때 쓰이는 모든 방법들_**
<br><br>이라 말할 수 있는 것이다.

>대표적 예시 ) 정렬, 탐색 , 재귀 등등 

----
**1.1.1. 정렬 알고리즘**

- 선택 정렬 : 스캔을 한사이클 돌리면서 최소값을 선택해서 아래부터 정렬하는 방법.

- 버블 정렬 : 두 개 씩 비교해서 큰 것은 오른쪽으로 밀어넣는 방식. 왼쪽에서 오른쪽으로 가면서 계속 반복시킨다.
끝까지 도달한 후 두 번 째부터 다시 실행.

- 삽입 정렬 : 하나를 뽑아서 전체적으로 비교해서 적당한 위치에 삽입하는 방법.
 
- 병합 정렬 : 각각의 시퀀스를 합병해가면서 각 구역마다 정렬을 진행, 그 이후 다시 그 구역들을 합병해서 비교해나가는 방식.

- 퀵 정렬 : 기준점을 세워서 그것보다 작은 것은 왼쪽, 큰 것은 오른쪽으로. 평균적으로 제일 빠른 정렬 방법에 속함.



**1.1.2. 탐색 알고리즘의 시간 복잡도**

< 시간 복잡도 >
-> 알고리즘이 실행되는데 소요되는 시간 분석
ex ) 점근 표기법 ( 대문자 O 표기법. Big O 표기법 : 알고리즘이 실행될 때 제일 오래걸리는 시간을 측정하려고 할 때 쓰임.) 
n을 최대 시간이라고 표현할 때,

O(n^2)으로 표현.

한번만 훑었을 때는 O(n).

선택 정렬의 시간 복잡도는 O(n^2)일 것.
버블 정렬의 시간 복잡도 역시 O(n^2)
하지만 퀵 정렬은 O(nlog2n)의 시간직접도를 가지고 있다.

* n은 최악의 경우를 가정해서 기준을 잡는다. 최악의 경우 n^2


- 선형 탐색 - O(n)
처음부터 하나씩 "순차적으로" 찾아가는 방식.

- 이진 탐색 - O(logn)
정렬된 데이터 셋 이상이 있어야 하고, 가운데 지점부터 조회를 하면서
원하는 데이터와 비교하고 그 결과에 따라 분할 정복 방식을 이용해서
조회를 필요로 하는 데이터 셋 사이즈를 1/2로 줄여나간다.

시간복잡도는 O(log n)이 됨.


크다 작다를 이진으로 표현해서 비교하는 것.

* 공간 복잡도 - 메모리를 차지하는 효율

------
#### 1.2. 자료구조

** 자료구조란 ? <br>**

>- 자료를 효율적으로 이용할 수 있는 방법론
>- 주기억장치에 올라와 있는 데이터를 구조적으로 표현하는 방식

** 자료구조 & 알고리즘이 필요한 이유?**

주기억장치는 한정적이고 작기 때문에, 자료를 효율적으로 활용해야 하기 때문이다.

```
ex) 테트리스
적절한 모양의 블럭(자료구조)을 요리조리 돌리고 옮겨(알고리즘)서 게임을 클리어
ex) 여행가방
효율적으로 물건들의 부피를 줄이고 (자료구조 ) 꺼낼 순서에 맞게 (알고리즘) 차곡차곡 정리해 넣는 방식.
```

#### 1.3. 자료구조 분류
- 원시구조 : 정수, 실수 , 문자
* 원시 구조에서 발전된 것이 배열이다.<br>


**1.3.1. 형태에 따른 분류 - 선형, 비선형 

```

- 선형구조 : 배열, 연결 리스트, 스택, 큐 , 덱

- 비선형구조 : 트리 , 그래프

< 스택 >
후입선출 : 먼저 들어간 것이 마지막에 나오고, 마지막에 들어간 것이 제일 먼저 나온다.

< 큐 >
선입선출 : 대기열 등이 대표적인 예시. 먼저 들어간 것이 먼저 나오는 것을 말함.

< Dequeue 덱 >
양쪽으로 통로를 뚫어 한쪽만이 아니라 다른 쪽에도 나갈 수 있는 방향을 뚫어 놓은 것.

< 트리 >
상위 노드와 하위 노드 / branch (가지) 로 나뉘며 상위 root 로 부터 가지처럼 세분화 되서 뻗어나간다.

< 그래프 >

```
<br>
**1.3.2. 유형에 따른 분류

- 물리적구조
 - 정수 , 실수, 문자
 - 배열, 연결 리스트

```
< 배열 >

배열의 장점 : 원하는 인덱스로 바로 조회 가능.<br>
배열의 단점 : 한 번 생성하면 추가, 삽입 , 삭제 등이 매우 복잡하고 어렵다. (한 번 생성하면 수정이 힘듬)


< 연결리스트 >

1. 단순 연결 리스트
- 연결리스트, 링크 필드에서 next필드의 정보값을 가지고 있으므로 전체적으로 무거울 수 밖에 없다.
- 순차적으로 찾아갈 수 밖에 없다. 랜덤으로 엑세스 할 수 있는 (접근 속도가 빠른 ) 배열보다 속도가 훨씬 느림.
- 인덱스 크기가 모두 같아야 하는 배열과는 달리, 연결리스트는 크기가 제각기여도 상관없다.
- 하지만 배열과 리스트의 속도 차이를 고려하지 않아도 될 만큼, 컴퓨터의 성능이 빨라졌으므로 지금은 신경 쓰지 않아도 될 문제.

2. 이중 연결 리스트
두 개의 리스트를 시작과 끝을 대칭시키고 그 둘을 이중으로 연결해서 앞 뒤 어느 방향으로도 시작(혹은 조회)할 수 있게 되었다.

3. 원형 연결 리스트


```


- 추상적 구조
 - 트리, 그리프, 스택, 큐 , 덱



#### 1.4. 데이터 베이스

**Database란?**

>- 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합

>- 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터들의 묶음.



** 자료구조 vs 데이터베이스**

자료구조 : 대부분 주기억장치에서 이루어질 내용

데이터베이스 : 대부분 보조기억장치에서 이루어질 내용

** 1.4.1. 데이터베이스 분류

> - 관계형(RDB)
제일 많이 쓰이는 db모델

>- 키-값형

>- 객체형

>- 문서형

> - 컬럼형
<br><br> 
(NoSQL 데이터베이스 모델은 익히기 어려운 관계형 데이터베이스 모델(비록 관계형이 상용화가 되어 있지만)를 쓰지 않아도 되는 틈새시장 공략. 관계형이 아닌 다른 객체형이나 키 값형 등을 통칭하기도 한다. )

#### 1.5. DBMS - DataBase Management system

- DB에 접근할 수 있는 기능을 제공하는 소프트웨어 .
- 즉 , 데이터베이스 계의 운영체제
- SQLite, MariaDB, MySQL, PostgreSQL


#### 1.6. SQL - Structured Query Language
- DBMS를 통해 데이터를 관리하기 위한 구조화된 질의문을 작성하기 위한 언어
- 관계형 데이터베이스 관리 시스템에서 사용.
- 즉, 시스템에게 명령어를 날릴 떄 쓰는 언어(질의문)가 SQL이라는 것.
- 특정 DB를 찾도록 요청하기 때문(질의).




## 2. 정리

- 자료구조와 알고리즘은 프로세스나 메모리를 좀더 효율적으로 관리/처리하기 위한 방법론
- 자료구조는 물건이 쌓여져 있는 구조 / 알고리즘은 물건을 쌓는 방법이라 말할 수 있다.
- DB란 여러 사람들에 의해 공유되어 통합 관리 되는 데이터들의 집합이며 그것에 접근할 수 있는 기능을 제공하는 것이 DBMS이다. 즉, OS 처럼 사용자와 DB 사이에 위치한 중간자의 존재라고 생각하면 이해하기 쉬울 것이다. 
- SQL은 질의문을 작성하기 위한 언어이다. 즉, DB를 찾으려고 할 때 DBMS에게 던지는 명령어라고 생각하자.