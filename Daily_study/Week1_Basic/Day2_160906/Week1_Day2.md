Week1_Day2. Operation /OS / Process / Scheduling / Kernel / 
==

## 0. 목차
>1. Operation 연산자 / 연산<br><br>
>2. OS 운영체제 <br><br>
>2. Process <br><br>
>3. Scheduling 스케줄링 기법<br><br>
>4. Kernel 커널<br><br>

## 1. 이론

#####1.1. Operation 연산자/ 연산<br>

1.1.1. 논리연산
- AND 논리곱 (A&B)
- OR 논리합 (A|B)
- NOT 반전연산 (~A)
- XOR 같으면 0을, 다르면 1을 결과물로 산출하는 연산 (A^B)

```
ex) 12 -3이라면

-3을 더하는 것. (2의 보수를 이용)
0011 -> 3
1100 -> NOT 3
여기에 1을 더해줘서

1101 -> 이것이 -3을 의미함.

12가 1100이고 -3이 1101이므로

더하면 11001.
```

1.1.2. 비트논리연산 vs 부울논리연산 <br><br>
```
            &          vs        &&
            |          vs        ||
```
- 비트논리연산 : 각 비트별 0과 1 계산<br>

1은 참을 의미, 0은 거짓을 의미하지만 

0이 아닌 다른 양의 정수라 하더라도 참이라고 여긴다.

```
ex)
0100 & 1101 = 0100

0110 && 1101 = true
참 && 참 일때만 참.
```
- 부울논리연산 : 참 거짓을 판별하는 연산이다.

```
ex)
true && false = false
 => 1111 && 0000 = 0000
true & false = false (이런 실수는 하면 안됨)
 => 1111 & 0000 = 0000
```
연산들은 실생활에도 많이 쓰이고 있는데, 
논리곱의 대표적인 예가 ORM이 있다.<br>
시험 볼 때 항상 작성하던 ORM 카드에 색칠한 것들을
Notification 으로 비교해서 참인지 거짓인지 판별하는 것.

```
A&B 연산(논리곱)
1100
0010
--------
0000
실제 답과 ORM카드를 비교해서 서로 다른 자리에 칠해져 있거나 빈칸이 겹치면 0 , 색이 칠해진 곳이 겹치면 1.
```

OR연산자(논리합 연산)는 설문조사 등에서 쓰일 수 있다.

```
OR연산(논리합)
사과     0001
바나나  0010
메론      0100
배         1000
라고 할 때 OR연산자(논리합)으로 A라는 사람의 설문조사 결과가 0111이라면
----------------
 결과     0111 -> A는 바나나, 메론, 배를 좋아한다.

```
<br>
##### 1.2. OS 운영체제
운영체제 : 컴퓨터를 사용하는 목적이 다양해지고 하드웨어의 모양새도 다양해지고 있는데, 하드웨어들을 제어하고 원하는 용도에 따라 효율적으로 사용하기 위해 만들어진 것.

**1.2.1. OS 종류** <br>
                  Unix                   /                  Linux                              /                            Windows
                                  BSD                   / Android, Ubuntu, CentOs,Fedora /                           Windows NT
                               Mac OS X            / 
                                                    UNIX-like OS (유닉스 계열)                       /

**1.2.2. OS 기능** <br>

>- 시스템 하드웨어 관리 : 사용자의 프로그램의 오류나 잘못된 자원 사용을 감시, 입출력 장치 등의 자원에 대한 연산과 제어를 관리

>- (가상) 시스템 서비스 제공 : 사용자에게 컴퓨터의 프로그램을 쉽고 효율적으로 실행할 수 있는 환경 제공.
ex) 바탕화면

>- 자원 관리(핵심기능) : 컴퓨터 시스템 하드웨어 및 소프트웨어 자원을 여러 사용자 간에 효율적 할당, 관리, 보호


<br>
##### 1.3. Process
프로세스 : 실제로 실행이 되고 있는 프로그램 ( 주기억장치)
프로그램 : 명령어들의 집합체일 뿐. 프로그램을 실행시켜야 프로세스. (보조기억장치)

< 프로세스 상태 >
- 생성 : 프로세스 생성
- 준비 : 중앙처리장치에 의해 프로세스가 실행되기를 기다리는 상태.
- 실행 : 중앙처리장치에 의해 프로세스가 실행된다.
- 대기 : 어떤 사건이 일어나기를 기다린다.
- 종료 : 프로세스가 종료된다.

##### 1.4 Kernel 커널

커널은 운영 체제의 핵심 부분이므로, 커널의 역할 역시 운영 체제의 핵심 역할이라 할 수 있다.

**1.4.1. 커널의 역할**

>- 보안<br>
커널은 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.

>- 자원 관리<br>
한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 한다. 특히 프로세스에 처리기를 할당하는 것을 스케줄링이라 한다.

>- 추상화<br>
같은 종류의 부품에 대해 다양한 하드웨어를 설계할 수 있기 때문에 하드웨어에 직접 접근하는 것은 문제를 매우 복잡하게 만들 수 있다. <br>
일반적으로 커널은 운영 체제의 복잡한 내부를 감추고 깔끔하고 일관성 있는 인터페이스를 하드웨어에 제공하기 위해 몇 가지 하드웨어 추상화(같은 종류의 장비에 대한 공통 명령어의 집합)들로 구현된다. <br>
이 하드웨어 추상화는 프로그래머가 여러 장비에서 작동하는 프로그램을 개발하는 것을 돕는다. 하드웨어 추상화 계층(HAL)은 제조사의 장비 규격에 대한 특정한 명령어를 제공하는 소프트웨어 드라이버에 의지한다.

출처 : 위키백과


##### 1.5. Scheduling 프로세스 스케쥴링
```
- FCFS(First-come First-served)
준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당

- SJF(Shortest job first)
실행 시간이 가장 짧은 프로세스에게 먼저 CPU 할당
평균 대기시간이 가장 적은 알고리즘
실행시간이 긴 프로세스에 밀려 무한 연기상태 발생가능
실행 시간이 누가 가장 빠른지 측정하는데도 코스트가 발생.

- Round Robin Scheduling - 시분할 시스템을 위해 고안된 방식, FCFS 기법 변형
   -> 각 프로세스는 시간 할당량 동안만 실행
   -> 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치
   -> 할당된 시간이 클수록 FCFS와 비슷
   -> 할당시간이 작을 수록 문맥 교환과 오버헤드가 자주 발생

- Priority Based Scheduling
    -> 프로세스마다 우선순위 부여
    -> 우선순위가 동일한 경우 FCFS 기법으로 할당
    -> 가장 낮은 순위를 부여받은 프로세스의 무한 연기 발생가능

- Multi Queue Scheduling
    -> 프로세스를 특정 그룹으로 분류할 수 있을 경우, 그룹에 따라 각기 다른 준비단계 큐 사용
    -> 준비상태 큐 마다 다른 스케줄링 기법 사용가능
    -> 다른 준비상태 큐로 이동 불가
    -> 하위 단계 준비 큐에 있는 프로세스를 실행하는 도중이라도 상위단계 준비단계 큐에 프로세스가 
    	들어오면 상위단계 프로세스에게 CPU를 할당
```
< 주기억장치 관리 >
 - 단순 관리

 - 가상 메모리

 - 보조 기억장치를 주기억장치처럼 활용

< 파일관리 > 파일 시스템 , 운영체제 마다 관리하는 방식에 차이가 있기 때문에 동작하는 방식이 다름. mac에는 디스크 조각 모음이 따로 없다거나 C: 라는 것이 없다는 차이점 등을 그 예로 들 수 있음.

응용 프로그램   <->   운영체제   <->   보조기억장치
                   파일입출력         파일입출력
                       요청                   처리

1. 응용 프로그램은 보조기억장치에 직접적으로 접근하지 않는다. 운영체제를 통해서 파일을 넘겨받을 뿐임.

2. 파일이 어디에 있는지 인덱싱을 통해서 파일관리.
그러므로, 파일을 삭제할 때도 사실 인덱스를 지우는 것이라 완전히 삭제 된 것은 아님.


- 중앙처리장치
- 주기억장치
- 보조기억장치
- 운영체제
- 응용프로그램
- 입출력장치

STEP

- 사용자 : 연산명령을 입력장치를 통해 전달
- 입력장치 : 응용 프로그램에게 사용자 입력 전달
- 응용 프로그램 : 주기억장치로 명령 복사
- 주기억장치 : CPU로 명령 복사
- CPU : 명령 수행 후 주기억장치로 결과 복사
- OS : 응용 프로그램에게 연산이 종료되었음을 알림
- 응용 프로그램 : 주기억장치에게 결과값 물어보기
- 응용 프로그램 : 결과값을 OS를 통하여 보조기억장치에 저장 요청
- 응용 프로그램 : 결과값을 출력장치로 전달
- 출력장치 : 사용자에게 결과값 안내

* cpu안에 연산/제어장치가 있는데, 주기억장치로 갈 때는 굳이 운영체제를 거치지 않고 스스로 연산하고 제어해서 버스를 통해
전달함.

## 2. 실습

>Role Play 

> 6명을 뽑아서 역할극을 진행한다.
>- 중앙처리장치
- 주기억장치
- 보조기억장치
- 운영체제
- 응용프로그램
>- 입출력장치

STEP

- 사용자 : 연산명령을 입력장치를 통해 전달
- 입력장치 : 응용 프로그램에게 사용자 입력 전달
- 응용 프로그램 : 주기억장치로 명령 복사
- 주기억장치 : CPU로 명령 복사
- CPU : 명령 수행 후 주기억장치로 결과 복사
- OS : 응용 프로그램에게 연산이 종료되었음을 알림
- 응용 프로그램 : 주기억장치에게 결과값 물어보기
- 응용 프로그램 : 결과값을 OS를 통하여 보조기억장치에 저장 요청
- 응용 프로그램 : 결과값을 출력장치로 전달
- 출력장치 : 사용자에게 결과값 안내

* cpu안에 연산/제어장치가 있는데, 주기억장치로 갈 때는 굳이 운영체제를 거치지 않고 스스로 연산하고 제어해서 버스를 통해 전달함.


* 주기억장치가 CPU로 명령 복사하는 것은 직접. CPU는 다시 주기억장치로 결과 복사

그 결과를 운영체제가 꺼내줘서 응용 프로그램에 갖다줌. - > 응용 프로그램이 응용체제를 통하여 보조기억장치에 결과값 저장.

=> 여러 프로세스가 실행 되었을 때 멀티태스킹 환경, 하지만 동시에 여러 일을 처리하는 것은 아니라, 준비 상태 실행 상태 등을 거쳐서 하나씩 실행.

## 3. 정리
- 논리곱/ 논리합 / 부울연산 / 비트연산

- OS는 user와 system 사이에서 프로세스들을 처리해주는 역할.
- 프로세스 스케줄링 기법 - 선입선출 , SJF, RoundRobin, 멀티큐(더블큐)
- 파일관리 시스템 - 버전관리 (git)
